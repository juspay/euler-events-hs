{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE DeriveAnyClass    #-}
{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE GADTs             #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeApplications  #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- | Generated by Haskell protocol buffer compiler. DO NOT EDIT!
module Euler.Proto.Event where

import           Control.Applicative     ((<$>), (<*>), (<|>))
import qualified Control.Applicative     as Hs
import qualified Control.DeepSeq         as Hs
import qualified Control.Monad           as Hs
import qualified Data.ByteString         as Hs
import qualified Data.Coerce             as Hs
import qualified Data.Int                as Hs (Int16, Int32, Int64)
import qualified Data.List.NonEmpty      as Hs (NonEmpty (..))
import qualified Data.Map                as Hs (Map, mapKeysMonotonic)
import qualified Data.Proxy              as Proxy
import qualified Data.String             as Hs (fromString)
import qualified Data.Text.Lazy          as Hs (Text)
import qualified Data.Vector             as Hs (Vector)
import qualified Data.Word               as Hs (Word16, Word32, Word64)
import qualified Euler.Proto.Event.Order as Event.Order
import qualified GHC.Enum                as Hs
import qualified GHC.Generics            as Hs
import qualified Prelude                 as Hs
import qualified Proto3.Suite.Class      as HsProtobuf
import qualified Proto3.Suite.DotProto   as HsProtobuf
import           Proto3.Suite.JSONPB     ((.:), (.=))
import qualified Proto3.Suite.JSONPB     as HsJSONPB
import qualified Proto3.Suite.Types      as HsProtobuf
import qualified Proto3.Wire             as HsProtobuf
import qualified Unsafe.Coerce           as Hs

data Event =
  Event
    { eventEvent :: Hs.Maybe EventEvent
    }
  deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)

instance HsProtobuf.Named Event where
  nameOf _ = (Hs.fromString "Event")

instance HsProtobuf.HasDefault Event

instance HsProtobuf.Message Event where
  encodeMessage _ Event {eventEvent = eventEvent} =
    (Hs.mconcat
       [ case eventEvent of
           Hs.Nothing -> Hs.mempty
           Hs.Just x ->
             case x of
               EventEventOrder y ->
                 (HsProtobuf.encodeMessageField
                    (HsProtobuf.FieldNumber 1)
                    (Hs.coerce
                       @(Hs.Maybe Event.Order.Order)
                       @(HsProtobuf.Nested Event.Order.Order)
                       (Hs.Just y)))
       ])
  decodeMessage _ =
    (Hs.pure Event) <*>
    (HsProtobuf.oneof
       Hs.Nothing
       [ ( (HsProtobuf.FieldNumber 1)
         , (Hs.pure (Hs.fmap EventEventOrder)) <*>
           (Hs.coerce
              @(_ (HsProtobuf.Nested Event.Order.Order))
              @(_ (Hs.Maybe Event.Order.Order))
              HsProtobuf.decodeMessageField))
       ])
  dotProto _ = []

instance HsJSONPB.ToJSONPB Event where
  toJSONPB (Event f1) =
    (HsJSONPB.object
       [ (let encodeEvent =
                (case f1 of
                   Hs.Just (EventEventOrder f1) -> (HsJSONPB.pair "order" f1)
                   Hs.Nothing                   -> Hs.mempty)
           in \options ->
                if HsJSONPB.optEmitNamedOneof options
                  then ("event" .= (HsJSONPB.objectOrNull [encodeEvent] options))
                         options
                  else encodeEvent options)
       ])
  toEncodingPB (Event f1) =
    (HsJSONPB.pairs
       [ (let encodeEvent =
                (case f1 of
                   Hs.Just (EventEventOrder f1) -> (HsJSONPB.pair "order" f1)
                   Hs.Nothing                   -> Hs.mempty)
           in \options ->
                if HsJSONPB.optEmitNamedOneof options
                  then ("event" .= (HsJSONPB.pairsOrNull [encodeEvent] options))
                         options
                  else encodeEvent options)
       ])

instance HsJSONPB.FromJSONPB Event where
  parseJSONPB =
    (HsJSONPB.withObject
       "Event"
       (\obj ->
          (Hs.pure Event) <*>
          (let parseEvent parseObj =
                 Hs.msum
                   [ Hs.Just Hs.. EventEventOrder <$>
                     (HsJSONPB.parseField parseObj "order")
                   , Hs.pure Hs.Nothing
                   ]
            in ((obj .: "event") Hs.>>= (HsJSONPB.withObject "event" parseEvent)) <|>
               (parseEvent obj))))

instance HsJSONPB.ToJSON Event where
  toJSON = HsJSONPB.toAesonValue
  toEncoding = HsJSONPB.toAesonEncoding

instance HsJSONPB.FromJSON Event where
  parseJSON = HsJSONPB.parseJSONPB

instance HsJSONPB.ToSchema Event where
  declareNamedSchema _ = do
    let declare_event = HsJSONPB.declareSchemaRef
    eventEvent <- declare_event Proxy.Proxy
    let _ = Hs.pure Event <*> HsJSONPB.asProxy declare_event
    Hs.return
      (HsJSONPB.NamedSchema
         { HsJSONPB._namedSchemaName = Hs.Just "Event"
         , HsJSONPB._namedSchemaSchema =
             Hs.mempty
               { HsJSONPB._schemaParamSchema =
                   Hs.mempty
                     { HsJSONPB._paramSchemaType =
                         Hs.Just HsJSONPB.SwaggerObject
                     }
               , HsJSONPB._schemaProperties =
                   HsJSONPB.insOrdFromList [("event", eventEvent)]
               }
         })

data EventEvent =
  EventEventOrder Event.Order.Order
  deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)

instance HsProtobuf.Named EventEvent where
  nameOf _ = (Hs.fromString "EventEvent")

instance HsJSONPB.ToSchema EventEvent where
  declareNamedSchema _ = do
    let declare_order = HsJSONPB.declareSchemaRef
    eventEventOrder <- declare_order Proxy.Proxy
    let _ = Hs.pure EventEventOrder <*> HsJSONPB.asProxy declare_order
    Hs.return
      (HsJSONPB.NamedSchema
         { HsJSONPB._namedSchemaName = Hs.Just "EventEvent"
         , HsJSONPB._namedSchemaSchema =
             Hs.mempty
               { HsJSONPB._schemaParamSchema =
                   Hs.mempty
                     { HsJSONPB._paramSchemaType =
                         Hs.Just HsJSONPB.SwaggerObject
                     }
               , HsJSONPB._schemaProperties =
                   HsJSONPB.insOrdFromList [("order", eventEventOrder)]
               , HsJSONPB._schemaMinProperties = Hs.Just 1
               , HsJSONPB._schemaMaxProperties = Hs.Just 1
               }
         })
